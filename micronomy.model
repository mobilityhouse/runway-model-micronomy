/*
 * Micronomy takes a stab at modelling a financial system in a manner that is
 * probably highly inaccurate and exaggerated.
 *
 * Company has operations and has a certain burn rate. This burn rate may be
 * more than the company produces, which will require the company to get its
 * resources elsewhere in order to sustain its operations.
 *
 * Party's have capital and may lend or loan capital to other parties. When
 * lending or loaning, a party is registered into the ledger and interest is
 * calculated on every term.
 */

type Id: 111111..999999; // Sloppy alternative for ids
var nextId: Id;
var idBlock: Boolean;

type Capital: 0..1000;
type Amount: 0..10;
type Party: record { id: Id, capital: Capital };

// NOTE: currently only supporting parent-child relationships, `equals` is
// used to indicate equality as in a peer-to-peer relationship.
type Relationship: record { parent: Party, child: Party, equals: Boolean };

type NetworkIndex: 0..10;
var network: Vector<Relationship>[NetworkIndex];

// NOTE: only allow general offers (exclusive offers aren't possible)
type Offer: record { source: Party, amount: Amount, value: Capital };
type Bid: record { source: Party, amount: Amount, value: Capital };

type LedgerIndex: 0..10;
type OfferLedgerIndex: LedgerIndex;
type BidLedgerIndex: LedgerIndex;

var currentOfferLedger: Vector<Offer>[OfferLedgerIndex];
var currentBidLedger: Vector<Bid>[BidLedgerIndex];

var age : 0..100;

rule tick {
  age = (age + 1) % 101;
}

// scene
type PartyIndex: 0..10;

var parties: Vector<Party>[PartyIndex];

rule spontaneouslySpawnParties {
  match (age % 10 == 5) {
    True {
      var _partySize: Array<Boolean>[PartyIndex];
      if(size(parties) < size(_partySize)) {
        push(parties, Party{capital: urandom<Capital>()});
      }
    }
    False {}
  }
}

rule spontaneouslyRemoveParties {
  match (age % 10 == 3) {
    True {
      if size(parties) > 0 {
        remove(parties, parties[urandomRange(0, size(parties)-1)]);
      }
    }
    False {}
  }
}

rule resetAfterTime {
  match(age % 20 == 0) {
    True {
      reset;
    }
    False {
    }
  }
}

rule addParty {
  var _partySize: Array<Boolean>[PartyIndex];
  if size(parties) < size(_partySize) {
    push(parties, Party{id: generateId(), capital: urandom<Capital>()});
  }
}

// TODO: Figure out effective method to remove multiple similar entries
rule addRelationship {
  if size(parties) > 1 {
    var parent : Party = parties[urandomRange(0, size(parties)-1)];
    var remaining : Vector<Party>[PartyIndex] = parties;
    remove(remaining, parent);
    var child : Party = remaining[urandomRange(0, size(remaining)-1)];
    push(network, Relationship{parent: parent, child: child, equals: False});
  }
}

var evalParent : Vector<Party>[1..100];
var evalChild : Vector<Party>[1..100];
var parentPushed : Vector<Party>[1..100];
var childPushed : Vector<Party>[1..100];
var evaluatedRelations : Vector<Relationship>[1..100];
var missingList: Vector<Boolean>[1..10];
var missingList2: Vector<Boolean>[1..10];
var sane : Boolean = False;
//var Code : 1..100;
//var log : Vector<Code>[1..100];

rule sanitizeNetwork {
  for relationId, relation in network {
    var parentExists : Boolean = contains(parties, relation.parent);
    var childExists : Boolean = contains(parties, relation.child);
    var memberMissing : Boolean = !(parentExists && childExists);
//    push(log, 0);
    push(missingList, memberMissing);

//    push(log, 2);
    if memberMissing {
//      push(log, 3);
      push(missingList, False);
      //push(evaluatedRelations, relation);
      push(missingList2, remove(network, relation));
//      push(log, 4);
    }
    /*
    if(!contains(parties, relation.parent) || !contains(parties, relation.child)) {
      push(parentPushed, relation.parent);
      push(parentPushed, relation.child);
      remove(network, relation);
    }
    push(evalParent, relation.parent);
    */
    /*
    if(!contains(parties, relation.parent)) {
      push(parentPushed, relation.parent);
    }
  
    push(evalChild, relation.child);
    if(!contains(parties, relation.child)) {
      push(childPushed, relation.child);
    }
    */
    //remove(parties, parties[0]);
    //for relationship in network {
    //}
  }
}

rule removeRandomParty {
  if size(parties) > 0 {
    remove(parties, parties[urandomRange(0, size(parties)-1)]);
  }
}

function generateId() -> Id {
  var tempId: Id;
  tempId = nextId;
  nextId+=1;
  return tempId;
}

// Set up handlers
