/*
 * Micronomy takes a stab at modelling a financial system in a manner that is
 * probably highly inaccurate and exaggerated.
 *
 * Company has operations and has a certain burn rate. This burn rate may be
 * more than the company produces, which will require the company to get its
 * resources elsewhere in order to sustain its operations.
 *
 * Party's have capital and may lend or loan capital to other parties. When
 * lending or loaning, a party is registered into the ledger and interest is
 * calculated on every term.
 */

// NOTE: currently only supporting parent-child relationships, `equals` is
// used to indicate equality as in a peer-to-peer relationship.
type Id: 111111..999999; // Sloppy alternative for ids
type Capital: 0..1000;

type Code : 1..100;
var loggingVector: Vector<Code>[1..100];

var nextId: Id;
var idBlock: Boolean;

type Amount: 0..10;
type Party: record { id: Id, capital: Capital };

type Relationship: record { parent: Party, child: Party, equals: Boolean };

type NetworkIndex: 0..10;
var network: Vector<Relationship>[NetworkIndex];
var testNetwork: Set<Relationship>[0..10];

//type Offer: record { source: Party, amount: Amount, value: Capital };
//type Bid: record { source: Party, amount: Amount, value: Capital };

//type LedgerIndex: 0..10;
//type OfferLedgerIndex: LedgerIndex;
//type BidLedgerIndex: LedgerIndex;

//var currentOfferLedger: Vector<Offer>[OfferLedgerIndex];
//var currentBidLedger: Vector<Bid>[BidLedgerIndex];

type PartyIndex: 0..10;

var parties: Vector<Party>[PartyIndex];

rule addParty {
  push(loggingVector, 10);
  var _partySize: Array<Boolean>[PartyIndex];
  if size(parties) < size(_partySize) {
    push(loggingVector, 11);
    push(parties, Party{id: generateId(), capital: urandom<Capital>()});
  }
  push(loggingVector, 12);
}

invariant validPartyList {
  
}

rule connectParties for _parentId, parent in parties for _childId, child in parties {
  push(loggingVector, 70);
  push(network, Relationship{ parent: parent, child: child, equals: False });
  push(loggingVector, 71);
}

/*
rule removeParty for _, party in parties {
  remove(parties, party);
}

rule removeRelationship for _, relationship in network {
  remove(network, relationship);
}
*/

function generateId() -> Id {
  var tempId: Id;
  tempId = nextId;
  nextId+=1;
  return tempId;
}
