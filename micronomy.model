/*
 * Micronomy takes a stab at modelling a financial system in a manner that is
 * probably highly inaccurate and exaggerated.
 *
 * Company has operations and has a certain burn rate. This burn rate may be
 * more than the company produces, which will require the company to get its
 * resources elsewhere in order to sustain its operations.
 *
 * Party's have capital and may lend or loan capital to other parties. When
 * lending or loaning, a party is registered into the ledger and interest is
 * calculated on every term.
 */

// NOTE: currently only supporting parent-child relationships, `equals` is
// used to indicate equality as in a peer-to-peer relationship.
type Index: 100..111; // Sloppy alternative for ids
type Capital: 0..1000;

type Code : 1..100;
var loggingVector: Vector<Code>[1..100];

type PartyIndex: Index;
type RelationshipIndex: Index;
type NetworkIndex: Index;

var nextIndex: Index;
var nextPartyIndex: PartyIndex;
var nextRelationshipIndex: RelationshipIndex;

var idBlock: Boolean;
var blockPartyIndex: Boolean;
var blockRelationshipIndex: Boolean;

type Amount: 0..10;
type Party : either {
  Nonexisting,
  Existing {
    id: Index,
    capital: Capital
  },
};

type Relationship : either {
  Empty,
  Unidirectional {
    parent: PartyIndex,
    child: PartyIndex,
  }
}

//type NetworkIndex: 0..10;
var oldNetwork: Vector<Relationship>[NetworkIndex];
var testNetwork: Set<Relationship>[0..10];

type Offer: record { source: Party, amount: Amount, value: Capital };
//type Bid: record { source: Party, amount: Amount, value: Capital };

type LedgerIndex: 0..10;
type OfferLedgerIndex: LedgerIndex;
//type BidLedgerIndex: LedgerIndex;

var currentOfferLedger: Vector<Offer>[OfferLedgerIndex];
//var currentBidLedger: Vector<Bid>[BidLedgerIndex];

type Message : either {
  Init {},
  AddParty {
    party: Party,
  },
  RemoveParty {
    party: Party,
  },
  AddRelationship {
    relationship: Relationship,
  },
  RemoveRelationship {
    relationship: Relationship,
  },
  Nothing {},
}

var parties: Vector<Party>[PartyIndex];

var manifest : Array<Party>[PartyIndex];
var network : Array<Relationship>[RelationshipIndex];
var message : Message;
var iteration : 0..100;

rule mutateHierarchy {
  match message {
    Init(p) {
      setupInitialNetwork();
    }
    AddParty(p) {
      push(parties, p.party);
    }
    RemoveParty(p) {
      remove(parties, p.party);
    }
    AddRelationship(r) {
      push(oldNetwork, r.relationship);
    }
    RemoveRelationship(r) {
      remove(oldNetwork, r.relationship);
    }
    default {}
  }
  message = Nothing {};
}

rule iterate {
  iteration = (iteration + 1) % 100;
}
/*
external request for party in parties {
  match party {
    Party(props) {
      push(currentOfferLedger, Offer { source: party, amount: 1, value: 10 });
    }
    default {}
  }
}

rule resolveNearbyOffer for offer in currentOfferLedger {
  for relation in network {
    if relation.child == offer.source {
      if relation.parent.capital > offer.value {
        remove(currentOfferLedger, offer);
        relation.parent.capital = relation.parent.capital - offer.value;
        relation.child.capital = relation.child.capital + offer.value;
      }
    }
  }
}
*/

function setupInitialNetwork() {
  addParty(generatePartyIndex(), 100);
  addParty(generatePartyIndex(),  50);
  addParty(generatePartyIndex(),  30);
  addParty(generatePartyIndex(),  10);
  addParty(generatePartyIndex(),   1);
/*
  push(parties, Party{id: generateIndex(), capital: 100});
  push(parties, Party{id: generateIndex(), capital:  50});
  push(parties, Party{id: generateIndex(), capital: 200});
  push(parties, Party{id: generateIndex(), capital: 200});
  push(parties, Party{id: generateIndex(), capital: 300});
  push(parties, Party{id: generateIndex(), capital:  10});

  push(oldNetwork, Relationship{parent: parties[0], child: parties[1]});
  push(oldNetwork, Relationship{parent: parties[1], child: parties[2]});
  push(oldNetwork, Relationship{parent: parties[1], child: parties[3]});
  push(oldNetwork, Relationship{parent: parties[0], child: parties[4]});
  push(oldNetwork, Relationship{parent: parties[4], child: parties[5]});
  */
}

function addParty(id: PartyIndex, capital: Capital) {
  manifest[id] = Existing { id: id, capital: capital };
}

function addRelationship(id: NetworkIndex, source: PartyIndex, target: PartyIndex) {
  //network[id] = Existing { id: id, parent: source, child: target };
}

function createParty(capital: Capital) {
  var generatedIndex : PartyIndex = generatePartyIndex();
  manifest[generatedIndex] = Existing { id: generatedIndex, capital: capital };
}

function createRelationship(a: PartyIndex, b: PartyIndex) {
  var generatedIndex : RelationshipIndex = generateRelationshipIndex();
  network[generatedIndex] = Unidirectional { parent: a, child: b };
}

function deleteParty(id: PartyIndex) {
  manifest[id] = Nonexisting;
}

function generateIndex() -> Index {
  var tempIndex: Index;
  tempIndex = nextIndex;
  nextIndex+=1;
  return tempIndex;
}

function generatePartyIndex() -> Index {
  var tempIndex: Index = nextPartyIndex;
  // TODO: check if next index exists and return EmptyIndex otherwise
  nextPartyIndex+=1;
  return tempIndex;
}

function generateRelationshipIndex() -> Index {
  var tempIndex: Index = nextRelationshipIndex;
  nextRelationshipIndex+=1;
  return tempIndex;
}

external removeParty for party in manifest {
  match party {
    Existing(props) {
      deleteParty(props.id);
    }
    default {}
  }
}

external newParty {
  createParty(20);
}

/*
external createRelationship for aId, a in parties for bId, b in parties {
  createRelationship(aId, bId);
}
*/
