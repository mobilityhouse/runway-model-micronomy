/*
 * Micronomy takes a stab at modelling a financial system in a manner that is
 * probably highly inaccurate and exaggerated.
 *
 * Company has operations and has a certain burn rate. This burn rate may be
 * more than the company produces, which will require the company to get its
 * resources elsewhere in order to sustain its operations.
 *
 * Party's have capital and may lend or loan capital to other parties. When
 * lending or loaning, a party is registered into the ledger and interest is
 * calculated on every term.
 */

type Id: 111111..999999; // Sloppy alternative for ids
var nextId: Id;
var idBlock: Boolean;

type Capital: 0..1000;
type Amount: 0..10;
type Party: record { id: Id, capital: Capital };

// NOTE: only allow general offers (exclusive offers aren't possible)
type Offer: record { source: Party, amount: Amount, value: Capital };
type Bid: record { source: Party, amount: Amount, value: Capital };

type LedgerIndex: 0..10;
type OfferLedgerIndex: LedgerIndex;
type BidLedgerIndex: LedgerIndex;
type CurrentOfferLedger: Vector<Offer>[OfferLedgerIndex];
type CurrentBidLedger: Vector<Bid>[BidLedgerIndex];

var age : 0..100;

rule tick {
  age = (age + 1) % 101;
}

// scene
type PartyIndex: 0..10;
type Relationship: record{ parent: PartyIndex, child: PartyIndex };

var parties: Vector<Party>[PartyIndex];

rule spontaneouslySpawnParties {
  match (age % 10 == 5) {
    True {
      var _partySize: Array<Boolean>[PartyIndex];
      if(size(parties) < size(_partySize)) {
        push(parties, Party{capital: urandom<Capital>()});
      }
    }
    False {}
  }
}

rule spontaneouslyRemoveParties {
  match (age % 10 == 3) {
    True {
      if size(parties) > 0 {
        remove(parties, parties[urandomRange(0, size(parties)-1)]);
      }
    }
    False {}
  }
}

rule resetAfterTime {
  match(age % 20 == 0) {
    True {
      reset;
    }
    False {
    }
  }
}

rule addParty {
  var _partySize: Array<Boolean>[PartyIndex];
  if size(parties) < size(_partySize) {
    push(parties, Party{id: generateId(), capital: urandom<Capital>()});
  }
}

rule removeRandomParty {
  if size(parties) > 0 {
    remove(parties, parties[urandomRange(0, size(parties)-1)]);
  }
}

function generateId() -> Id {
  var tempId: Id;
  tempId = nextId;
  nextId+=1;
  return tempId;
}

// Set up handlers
