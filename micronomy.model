/*
 * Micronomy takes a stab at modelling a financial system in a manner that is
 * probably highly inaccurate and exaggerated.
 *
 * Company has operations and has a certain burn rate. This burn rate may be
 * more than the company produces, which will require the company to get its
 * resources elsewhere in order to sustain its operations.
 *
 * Party's have capital and may lend or loan capital to other parties. When
 * lending or loaning, a party is registered into the ledger and interest is
 * calculated on every term.
 */

// NOTE: currently only supporting parent-child relationships, `equals` is
// used to indicate equality as in a peer-to-peer relationship.
type Id: 111111..999999; // Sloppy alternative for ids
type Capital: 0..1000;

type Code : 1..100;
var loggingVector: Vector<Code>[1..100];

var nextId: Id;
var idBlock: Boolean;

type Amount: 0..10;
type Party: record { id: Id, capital: Capital };

type Relationship: record { parent: Party, child: Party, equals: Boolean };

type NetworkIndex: 0..10;
var network: Vector<Relationship>[NetworkIndex];
var testNetwork: Set<Relationship>[0..10];

//type Offer: record { source: Party, amount: Amount, value: Capital };
//type Bid: record { source: Party, amount: Amount, value: Capital };

//type LedgerIndex: 0..10;
//type OfferLedgerIndex: LedgerIndex;
//type BidLedgerIndex: LedgerIndex;

//var currentOfferLedger: Vector<Offer>[OfferLedgerIndex];
//var currentBidLedger: Vector<Bid>[BidLedgerIndex];

type Message : either {
  Init {},
  AddParty {
    party: Party,
  },
  RemoveParty {
    party: Party,
  },
  AddRelationship {
    relationship: Relationship,
  },
  RemoveRelationship {
    relationship: Relationship,
  },
  Nothing {},
}

type PartyIndex: 0..10;

var parties: Vector<Party>[PartyIndex];
var message : Message;

rule mutateHierarchy {
  match message {
    Init(p) {
      setupInitialNetwork();
    }
    AddParty(p) {
      push(parties, p.party);
    }
    RemoveParty(p) {
      remove(parties, p.party);
    }
    AddRelationship(r) {
      push(network, r.relationship);
    }
    RemoveRelationship(r) {
      remove(network, r.relationship);
    }
    default {}
  }
  message = Nothing {};
}

function generateId() -> Id {
  var tempId: Id;
  tempId = nextId;
  nextId+=1;
  return tempId;
}

function setupInitialNetwork() {
  push(parties, Party{id: generateId(), capital: 100});
  push(parties, Party{id: generateId(), capital:  50});
  push(parties, Party{id: generateId(), capital: 200});
  push(parties, Party{id: generateId(), capital: 200});
  push(parties, Party{id: generateId(), capital: 300});
  push(parties, Party{id: generateId(), capital:  10});

  push(network, Relationship{parent: parties[0], child: parties[1]});
  push(network, Relationship{parent: parties[1], child: parties[2]});
  push(network, Relationship{parent: parties[1], child: parties[3]});
  push(network, Relationship{parent: parties[0], child: parties[4]});
  push(network, Relationship{parent: parties[4], child: parties[5]});
}
