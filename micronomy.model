/*
 * Micronomy takes a stab at modelling a financial system in a manner that is
 * probably highly inaccurate and exaggerated.
 *
 * Company has operations and has a certain burn rate. This burn rate may be
 * more than the company produces, which will require the company to get its
 * resources elsewhere in order to sustain its operations.
 *
 * Party's have capital and may lend or loan capital to other parties. When
 * lending or loaning, a party is registered into the ledger and interest is
 * calculated on every term.
 */
type Index: 100..130; // Sloppy alternative for ids
type Capital: 0..1000;

type Code : 1..100;
var loggingVector: Vector<Code>[1..100];

type PartyIndex: Index;
type RelationshipIndex: Index;
type NetworkIndex: Index;
type MessageIndex: Index;

var nextIndex: Index;
var nextPartyIndex: PartyIndex;
var nextRelationshipIndex: RelationshipIndex;

var idBlock: Boolean;
var blockPartyIndex: Boolean;
var blockRelationshipIndex: Boolean;

type Amount: 0..10;

type Name : either {
  Undefined,
  EU,
  DE,
  BER,
  MUC,
  FRA,
  HAM,
  KOL,
  TMH,
  Garage,
  Reichstagg,
  P,
  LIS,
  LandingJobsFest,
  UK
};

type Party : either {
  Nonexisting,
  Existing {
    id: Index,
    capital: Capital,
    name: Name
  },
};

type Relationship : either {
  Empty,
  Unidirectional {
    parent: PartyIndex,
    child: PartyIndex,
  }
};

type Message : record {
  conduit: Relationship
/*
  OfferRequest {
    amount: Amount,
    value: Capital,
    relationship: RelationshipIndex,
  }
*/
};

type Offer: record { source: PartyIndex, amount: Amount, value: Capital };
//type Bid: record { source: Party, amount: Amount, value: Capital };

type LedgerIndex: 0..10;
type OfferLedgerIndex: LedgerIndex;
//type BidLedgerIndex: LedgerIndex;

var currentOfferLedger: Vector<Offer>[OfferLedgerIndex];
//var currentBidLedger: Vector<Bid>[BidLedgerIndex];

var parties: Vector<Party>[PartyIndex];

var manifest : Array<Party>[PartyIndex];
var network : Array<Relationship>[RelationshipIndex];
var queue : Vector<Message>[MessageIndex];

var iteration : 0..100;
var countHandledOffers : 0..1000;

rule iterate {
  iteration = (iteration + 1) % 100;
}

external init {
  setupInitialNetwork();
}

external makeOffer for party in manifest {
  match party {
    Existing(props) {
      push(currentOfferLedger, Offer { source: props.id, amount: 1, value: 10 });
    }
    default {}
  }
}

external message for party in manifest {
  match party {
    Existing(sender) {
      push(loggingVector, 12);
      for relationship in network {
        match relationship {
          Unidirectional(rel) {
            push(loggingVector, 13);
            if(sender.id == rel.child) {
              push(loggingVector, 14);
              push(queue, Message { conduit: relationship });
            }
          }
          default {}
        }
      }
    }
    default {}
  }
}

// Perform exchange between child and parent if capital is sufficient
rule resolvePossibleAdjacentTransaction for offer in currentOfferLedger {
  for relation in network {
    match relation {
      Unidirectional(rel) {
        if rel.child == offer.source {
          match manifest[rel.parent] {
            Existing(party) {
              if party.capital >= offer.value {
                remove(currentOfferLedger, offer);
                moveCapital(rel.parent, rel.child, offer.value);
                countHandledOffers+=1;
              }
            }
            default {}
          }
        }
      }
      default {}
    }
  }
}

// TODO: figure out if you can use one of the either enums as a type such as
// taking an argument that is an Existing instead of a Party and then having
// to match on it.
function setupInitialNetwork() {
  // Germany
  var nGermany: PartyIndex = createParty(100, DE);
  var nBerlin: PartyIndex = createParty( 50, BER);
  createRelationship(nGermany, nBerlin);
  var nReich: PartyIndex = createParty(40, Reichstagg);
  createRelationship(nBerlin, nReich);
  var nMunich: PartyIndex = createParty(30, MUC);
  createRelationship(nGermany, nMunich);
  var nFrankfurt: PartyIndex = createParty(30, FRA);
  createRelationship(nGermany, nFrankfurt);
  var nHamburg: PartyIndex = createParty(20, HAM);
  createRelationship(nGermany, nHamburg);
  var nKoln: PartyIndex = createParty(20, KOL);
  createRelationship(nGermany, nKoln);
  var nTMH : PartyIndex = createParty(40, TMH);
  createRelationship(nMunich, nTMH);
  var nTMHGarage: PartyIndex = createParty(20, Garage);
  createRelationship(nTMH, nTMHGarage);

  // Portugal
  var nPortugal: PartyIndex = createParty(10, P);
  var nLisbon: PartyIndex = createParty(10, LIS);
  createRelationship(nPortugal, nLisbon);
  var nLandingFest: PartyIndex = createParty(12, LandingJobsFest);
  createRelationship(nLisbon, nLandingFest);

  var nEurope: PartyIndex = createParty(20, EU);
  var nUK: PartyIndex = createParty(10, UK);
  createRelationship(nEurope, nUK);
  createRelationship(nEurope, nGermany);
}

function addParty(id: PartyIndex, capital: Capital, name: Name) {
  manifest[id] = Existing { id: id, capital: capital, name: name };
}

function addRelationship(id: NetworkIndex, source: PartyIndex, target: PartyIndex) {
  network[id] = Unidirectional { parent: source, child: target };
}

function createParty(capital: Capital, name: Name) -> PartyIndex {
  var generatedIndex : PartyIndex = generatePartyIndex();
  addParty(generatedIndex, capital, name);
  return generatedIndex;
}

function createRelationship(a: PartyIndex, b: PartyIndex) {
  var generatedIndex : RelationshipIndex = generateRelationshipIndex();
  network[generatedIndex] = Unidirectional { parent: a, child: b };
}

function deleteParty(id: PartyIndex) {
  manifest[id] = Nonexisting;
}

function deleteRelationship(id: RelationshipIndex) {
  network[id] = Empty;
}

function generateIndex() -> Index {
  var tempIndex: Index;
  tempIndex = nextIndex;
  nextIndex+=1;
  return tempIndex;
}

function generatePartyIndex() -> Index {
  var tempIndex: Index = nextPartyIndex;
  // TODO: check if next index exists and return EmptyIndex otherwise
  nextPartyIndex+=1;
  return tempIndex;
}

function generateRelationshipIndex() -> Index {
  var tempIndex: Index = nextRelationshipIndex;
  nextRelationshipIndex+=1;
  return tempIndex;
}

function moveCapital(from: PartyIndex, to: PartyIndex, amount: Capital) -> Boolean {
  match manifest[from] {
    Existing(payer) {
      match manifest[to] {
        Existing(recipient) {
          if(((payer.capital-0) >= amount) && ((1000-recipient.capital) >= amount)) {
            payer.capital = payer.capital-amount;
            recipient.capital = recipient.capital+amount;
            manifest[from] = payer;
            manifest[to] = recipient;
            return True;
          }
        }
        default {}
      }
    }
    default {}
  }
  return False;
}
function decreaseCapital(id: PartyIndex, amount: Capital) -> Boolean {
  match manifest[id] {
    Existing(party) {
      if (party.capital-0) > amount {
        party.capital = party.capital-amount;
        manifest[id] = party;
        return True;
      }
    }
    default {}
  }
  return False;
}

function increaseCapital(id: PartyIndex, amount: Capital) -> Boolean {
  match manifest[id] {
    Existing(party) {
      if (1000-party.capital) > amount {
        party.capital = party.capital+amount;
        manifest[id] = party;
        return True;
      }
    }
    default {}
  }
  return False;
}

external newParty {
  createParty(20, Name{});
}

external removeParty for party in manifest {
  match party {
    Existing(props) {
      deleteParty(props.id);
    }
    default {}
  }
}

external newRelationship for a in manifest for b in manifest {
  match a {
    Existing(parent) {
      match b {
        Existing(child) {
          createRelationship(parent.id, child.id);
        }
        default { }
      }
    }
    default { }
  }
}

external removeRelationship for relationshipIndex, relationship in network {
  match relationship {
    Unidirectional {
      deleteRelationship(relationshipIndex);
    }
    default {}
  }
}
